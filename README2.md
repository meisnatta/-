# Анализ алгоритмов сортировки и поиска
## Алгоритмы сортировки
### Блочная (корзинная) сортировка

 Определение:
Блочная сортировка (bucket sort) — это алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их значений. После этого каждая корзина сортируется отдельно, и отсортированные корзины объединяются обратно в один массив.

 Пример кода на Python:
```
def bucket_sort(arr):
    """
    Блочная (корзинная) сортировка для чисел с плавающей точкой
    """
    if len(arr) == 0:
        return arr
    
    num_buckets = len(arr)
    max_val = max(arr)
    min_val = min(arr)
    
    buckets = [[] for _ in range(num_buckets)]
    
    for num in arr:
        index = int((num - min_val) / (max_val - min_val + 1e-10) * num_buckets)
        buckets[index].append(num)
    
    for i in range(num_buckets):
        buckets[i].sort()
    
    result = []
    for bucket in buckets:
        result.extend(bucket)
    
    return result

# Тестирование
if __name__ == "__main__":
    arr = [0.42, 0.32, 0.33, 0.52, 0.37, 0.47, 0.51]
    print("Исходный массив:", arr)
    sorted_arr = bucket_sort(arr)
    print("Отсортированный массив:", sorted_arr)
```
 Результаты работы:

Исходный массив: [0.42, 0.32, 0.33, 0.52, 0.37, 0.47, 0.51]
Отсортированный массив: [0.32, 0.33, 0.37, 0.42, 0.47, 0.51, 0.52]

 Принцип работы:

    buckets = [[] for _ in range(num_buckets)] - создаем пустые корзины

    index = int((num - min_val) / (max_val - min_val + 1e-10) * num_buckets) - вычисляем индекс корзины для каждого элемента

    buckets[i].sort() - сортируем каждую корзину индивидуально

    result.extend(bucket) - объединяем все корзины в результат

 Временная сложность: O(n + k)

 Объяснение: В лучшем случае при равномерном распределении - O(n), в худшем (все элементы в одной корзине) - O(n²)

### Блинная сортировка

### Определение:
Блинная сортировка (pancake sort) — это метод, основанный на операции переворота (reversal) части массива. Единственная разрешённая операция — переворот префикса массива до выбранного индекса.
### Пример кода на Python:
```
def flip(arr, i):
    """Переворачивает массив от 0 до i"""
    start = 0
    while start < i:
        arr[start], arr[i] = arr[i], arr[start]
        start += 1
        i -= 1

def find_max(arr, n):
    """Находит индекс максимального элемента в массиве до n"""
    max_idx = 0
    for i in range(1, n):
        if arr[i] > arr[max_idx]:
            max_idx = i
    return max_idx

def pancake_sort(arr):
    """Блинная сортировка"""
    n = len(arr)
    
    for curr_size in range(n, 1, -1):
        max_idx = find_max(arr, curr_size)
        
        if max_idx != curr_size - 1:
            if max_idx != 0:
                flip(arr, max_idx)
            flip(arr, curr_size - 1)
    
    return arr

# Тестирование
if __name__ == "__main__":
    arr = [23, 10, 20, 11, 12, 6, 7]
    print("Исходный массив:", arr)
    sorted_arr = pancake_sort(arr.copy())
    print("Отсортированный массив:", sorted_arr)
```
### Результаты работы:

Исходный массив: [23, 10, 20, 11, 12, 6, 7]
Отсортированный массив: [6, 7, 10, 11, 12, 20, 23]

### Принцип работы:

    find_max(arr, curr_size) - находим максимальный элемент в неотсортированной части

    flip(arr, max_idx) - переворачиваем до максимального элемента, чтобы он оказался первым

    flip(arr, curr_size - 1) - переворачиваем весь подмассив, чтобы максимальный элемент оказался в конце
    
### Временная сложность:O(n²)

### Объяснение: Для каждого элемента выполняется поиск максимума (O(n)) и два переворота (O(n)), что в сумме дает O(n²)






### Блинная сортировка
### Определение:
### Пример кода на Python:
```
```
### Результаты работы:
### Принцип работы:
### Временная сложность:
### Объяснение:

